<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <script>
        // {}: 객체의 리터럴
        // 리터럴이란 변수로 할당하기 이전의 값을 의미한다
        // let myObj = {
        //     val1: 10,
        //     val2: 30
        // }

        //배열 안 배열일때 ([],[])
        // let fruit = (["메론", "수박"], ["포도", "체리"]);
        // let fruit2 = [["메론", "수박"], ["포도", "체리"]];
        
        // 일반적인 배열 방법 []

        // 배열을 생성하는 방법
        // 1. 배열 리터럴로 선언([])
        // 2. 배열 생성자로 선언(new Array())

        // 베열은 접근과 수정이 둘 다 가능하다
        // let myArray2 = new Array(5, 3, 2);
        // console.log(myArray2[0]); // 5 (접근)
        // myArray2[0] = 100; // 수정
        // console.log(myArray2); //[100, 3, 2] 

        // 배열처럼 접근가능한 데이터 타입이 있는데 string이다.
        // string의 특징(불변성)
        // 불변성: 접근은 가능하지만 수정이 불가능하다
        // let val = "hello";
        // console.log(val[1]); // "e" (접근)
        // val[2] = "z"; 
        // console.log(val); // "hello" (수정X)

        const cafe = ['coffee', 'cake', 'tea', 'cookie'];
        // 1. 배열이란
        // 배열은 대괄호를 이용해 여러 개의 값을 리스트 형태로 나열한 자료구조를 뜻하며 ‘인덱스로 참조되는 요소’라는 값의 집합이다. 여기서 배열의 요소(element)는 배열을 구성하는 각각의 값이고 배열에서 요소의 위치를 가리키는 숫자를 인덱스(index)라고 한다. 이 배열을 다루기 위해 다수의 메소드가 제공되는데 이를 이용해 효율적으로 값에 접근할 수 있다. 

        // 2. 배열 특징
        // (1) 요소의 값을 수정할 수 있고 인덱스로 요소의 값을 호출 할 수 있다. 
        // (2) JavaScript의 배열은 배열 타입으로 존재하지 않고 객체 타입으로 존재(자료구조에 나오는 엄밀한 의미인 ‘메모리 상의 연속 배치의 배열’이 아니다.)
        // (3) 값의 참조가 인덱스로 이루어진다.(일반적인 객체와의 가장 큰 차이인데, 인덱스와 length 프로퍼티가 존재)

        // 2-1. 값의 호출, 변경
        // console.log(cafe[0])
        // cafe[0] = 'tea'  //['tea', 'cake', 'tea', 'cookie']

        // 2-2. 프로퍼티 length
        // cafe.length  //4


        // 3. 배열 메소드
        // 3-1. 맨 앞에서 요소를 추가할 때에는 unshift()
        // cafe.unshift('bread');  //['bread', 'coffee', 'cake', 'tea', 'cookie']

        // 3-2. 맨 앞에서 요소를 지울 때에는 shift()
        // cafe.shift();  //['cake', 'tea', 'cookie']

        // 3-3. 맨 뒤에서 요소를 추가할 때에는 push()
        // cafe.push('bread')  //['coffee', 'cake', 'tea', 'cookie', 'bread']

        // 3-4. 맨 뒤에서 요소를 제거할 때에는 pop()
        // cafe.pop();  //['coffee', 'cake', 'tea']

        // 3-5. 특정한 인덱스에 요소를 위치시킬 때에는 splice(요소를 위치시키고자 하는 인덱스, 제거할 요소의 개수)
        // cafe.splice(1, 0, 'bread');  //'coffee', 'bread', 'cake', 'tea', 'cookie']
        // cafe.splice(-1, 2, 'bread');  //['coffee', 'cake', 'tea', 'bread']

        // 3-6. 특정 요소를 제거할 때에도 splice(요소를 위치시키고자 하는 인덱스, 제거할 요소의 개수)
        // cafe.splice(1, 2);  // ['coffee', 'cookie']

        // 3-7. 배열 일부분을 잘라내서 새로운 배열로 반환할 때에는 slice()
        // cafe.slice(1, 3);  // ['cake', 'tea']
        // cafe.slice(2);  // ['tea', 'cookie']
        // cafe.slice(-2, -1);  //['tea']
        // cafe.slice(0, -2);  //['coffee', 'cake']

        // 3-8. 순서를 거꾸로 뒤집고 싶다면 reverse() (원본 배열을 변경시킨다)
        // cafe.reverse();  //['cookie', 'tea', 'cake', 'coffee']

        // 3-9. 요소의 인덱스를 찾고 싶을 때에는 indexOf(요소, 탐색을 시작하고자 하는 인덱스)
        // cafe.indexOf('tea')  // 2
        // cafe.indexOf('coffe', 1)  // -1 (해당 인덱스에서 지정된 요소가 탐색되지 않을 시 -1을 출력한다.)
        // cafe.indexOf('bread')  // -1 (배열에 존재하지 않는 요소일 경우 -1을 출력한다.)

        // 3-10. 인자가 배열인지 확인하고 싶을 때에는 isArray()
        // Array.isArray('coffee');  //false
        // Array.isArray(false);  //false
        // Array.isArray([1]);  //true

        // 3-11. 요소들을 연결해 하나의 값으로 만들 때에는 join() (원본을 수정하지 않는다)
        // cafe.join('/');  //'coffee/cake/tea/cookie'
        // JS tip) Method Chaining : 메소드 연달아서 사용 (join과 split chaining)
        // console.log(cafe.join('/').split('/'));
        // cafe.join(''); //'coffeecaketeacookie'

        // 3-12. 모두 똑같은 요소로 채우고 싶다면 fill(배열 내에 채우고자 하는 값, 채우기 시작할 지점의 인덱스, 어디까지 입력할지 종료지점을 정하는 인덱스) (원본 배열을 변경시킨다)
        // cafe.fill('bread');  //['bread', 'bread', 'bread', 'bread']
        // cafe.fill('bread', -1);  //['coffee', 'cake', 'tea', 'bread']
        // cafe.fill('bread', -3, -1);  //['coffee', 'bread', 'bread', 'cookie']

        // 3-13. 배열을 원하는 깊이로 평탄화하고 싶다면 flat()
        // let arr = [[1, 2, 3], [4, 5, 6], [7, 8, [9, [10, 11]]]]
        // arr.flat();  //[1, 2, 3, 4, 5, 6, 7, 8, [9, [10, 11]]]
        // arr.flat(1);  //[1, 2, 3, 4, 5, 6, 7, 8, [9, [10, 11]]]
        // arr.flat(2);  //[1, 2, 3, 4, 5, 6, 7, 8, 9, [10, 11]]
        // arr.flat(3);  //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
        // arr.flat(Infinity);  //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

        // 3-14. 특정 요소가 포함되었는지 확인할 때에는 includes()
        // cafe.includes('bread');  //false
        // cafe.includes('cake');  //true
        // cafe.includes('cake', -3);  //true

        // 3-15. 하나의 요소라도 조건을 만족하는지 확인할 때에는 find()
        // const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        // arr.find(i => i > 5);  //6

        // Arrow function( => ): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions

        // 3-16. 모든 요소가 조건을 만족하는지 확인할 때에는 filter()
        // const arr = [{
        //     'name' : 'title1',
        //     'contents' : 'contents1',
        //     'dataNum' : 1
        // }, {
        //     'name' : 'title2',
        //     'contents' : 'contents2',
        //     'dataNum' : 2
        // }, {
        //     'name' : 'title3',
        //     'contents' : 'contents3',
        //     'dataNum' : 3
        // }, {
        //     'name' : 'title4',
        //     'contents' : 'contents4',
        //     'dataNum' : 4
        // }, {
        //     'name' : 'title5',
        //     'contents' : 'contents5',
        //     'dataNum' : 5
        // }];

        // arr.filter(i => i.dataNum > 3);

        // //expected output:
        // [{
        //     'name' : 'title4',
        //     'contents' : 'contents4',
        //     'dataNum' : 4
        // }, {
        //     'name' : 'title5',
        //     'contents' : 'contents5',
        //     'dataNum' : 5
        // }]

        // 3-17. 조건을 만족하는 첫 번째 인덱스를 찾을 때 findIndex()

        // const cafe = [{
        //     'item' : 'coffee',
        //     'amount' : 5
        // },{
        //     'item' : 'cake',
        //     'amount' : 4
        // },{
        //     'item' : 'tea',
        //     'amount' : 7
        // },{
        //     'item' : 'cookie',
        //     'amount' : 3
        // }];

        // const index = cafe.findIndex(obj => obj.item.length <= 3);

        // index;
        //expected output: 2

        // 3-18. 각각 요소에 함수를 호출할 때에는 map()

        // const arr = [{
        //     'name' : 'title1',
        //     'contents' : 'contents1',
        //     'dataNum' : 1,
        //     'data' : [1, 2, 3]
        // }, {
        //     'name' : 'title2',
        //     'contents' : 'contents2',
        //     'dataNum' : 2,
        //     'data' : [1, 2, 3]
        // }, {
        //     'name' : 'title3',
        //     'contents' : 'contents3',
        //     'dataNum' : 3,
        //     'data' : [1, 2, 100]
        // }, {
        //     'name' : 'title4',
        //     'contents' : 'contents4',
        //     'dataNum' : 4,
        //     'data' : [1, 2, 3]
        // }, {
        //     'name' : 'title5',
        //     'contents' : 'contents5',
        //     'dataNum' : 5,
        //     'data' : [1, 2, 100]
        // }];


        // arr.map(i => i.name);
        // //expected output: ['title1', 'title2', 'title3', 'title4', 'title5']

        // arr.map(i => i.name).indexOf('title3');
        // //expected output: 2

        // arr.map((i) => {
        //     if (i.data.includes(100)) {
        //         return i.name
        //     }
        //     return 
        // }).filter(i => i);
        // //expected output: ['title3', 'title5']

        // 예제
        // var studentList = [
        //     {
        //         id: 1, name: '원범', score: 'great'
        //     },
        //     {
        //         id: 2, name: '김진', score: 'nice'
        //     },
        //     {
        //         id: 3, name: '혜원', score: 'good'
        //     },
        //     {
        //         id: 4, name: '재현', score: 'too cool for school'
        //     }
        // ];

        // const myArr = studentList.map(
        //     function (i) {
        //         return i.name
        //     }
        // )

        //filter는 조건 메소드가 자체적으로 있고 map은 따로 없다(함수자리에 조건문을 걸면 메소드처럼 쓸 수 있다)

        // 3-19. 함수를 실행하는 동시에 배열을 평탄화할 때에는 flatMap()
        // const coffee = ["iced americano and latte", "espresso", " ", "macchiato", " ", "cappuccino"]

        // const map = coffee.map(i => i.split(' '));
        // //expected output: [['iced', 'americano', 'and', 'latte'], ['espresso'], ['', ''], ['macchiato'], ['', ''], ['cappuccino']

        // const flapMap = coffee.flatMap(i => i.split(' '));
        // //expected output: ['iced', 'americano', 'and', 'latte', 'espresso', '', '', 'macchiato', '', '', 'cappuccino']

        // 3-20. 각각의 요소를 실행하고 싶을 때에는 forEach()
        // const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

        // arr.forEach(i => console.log(i));
        // // expected output: 1
        // // expected output: 2
        // // expected output: 3
        // // expected output: 4
        // // expected output: 5
        // // expected output: 6
        // // expected output: 7
        // // expected output: 8
        // // expected output: 9
        // // expected output: 10

        // 3-21. 각 요소에 누적해주며 실행하고 싶을 때에는 reduce()
        // const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

        // arr.reduce((누적값, 현재값) => 누적값+현재값)
        // //expected output: 55

        // arr.reduce((누적값, 현재값, index, array) => 누적값+현재값)
        // //expected output: 55

        // arr.reduce((누적값, 현재값, index, array) => 누적값-현재값)
        // //expected output: -53

        // 3-22. 유사 배열 객체를 배열로 만들 때에는 Array.from()
        // Array.from('hello world');
        // //expected output: ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']

        // Array.from([1, 2, 3], x => x ** 2);
        // //expected output: [1, 4, 9]

        // Array.from([{'value':100}, {'value':200}, {'value':300}], x => x.value);
        // //expected output: [100, 200, 300]

        // 3-23. 배열을 합치거나 새로운 요소를 추가할 때에는 concat()
        // const cafe = ['coffee'];

        // cafe.concat(['cake']);
        // //expected output: ['coffee', 'cake']

        // cafe.concat(['tea'], 'cookie');
        // //expected output: ['coffee', 'tea', 'cookie']

        // 3-24. 배열 내 요소를 정렬할 때에는 sort()
        // const arr = [3, 4, 1, 2]
        // arr.sort();
        // //expected output: [1, 2, 3, 4]

        // const vegetable = ['beet', 'carrot', 'apple']
        // vegetable.sort();
        // //expected output: ['apple', 'beet', 'carrot']

        // ** 주의 ** JavaScript의 sort 메소드는 문자열로 바꿔서 정렬한다.(아래 자료 참조)
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
        // number타입 해결방안

        // const arrNum = [13, 9, 10, 2];

        // 원본을 수정하지 않고 정렬하는 방법(스프레드 기법)
        // let arrNum_test = [13, 9, 10, 2];
        // [...arrNum_test].sort(); // [10, 13, 2, 9]


        // // arrNum.sort();  //[10, 13, 2, 9]
        // arrNum.sort( function (a, b) {
        //     console.log(`a: ${a}`, `b: ${b}`);
        //     // result
        //     // a: 9 b: 13
        //     // a: 10 b: 9
        //     // a: 10 b: 13
        //     // a: 10 b: 9
        //     // a: 2 b: 10
        //     // a: 2 b: 9

        //     // 우리가 보기에는 bubble sorting처럼 정렬되는 과정을 볼 수 있다(실제로는 InsertionSort랑 QuickSort를 사용)
        //     // 9 - 13 ==> 음수 ==> [9, 13, 10, 2]
        //     // 10 - 9 ==> 양수 ==> [9, 13, 10, 2]
        //     // 10 -13 ==> 음수 ==> [9, 10, 13, 2]
        //     // 10 - 9 ==> 양수 ==> [9, 10, 13, 2]
        //     // 2 - 10 ==> 음수 ==> [9, 2, 10, 13]
        //     // 2 - 9 ==> 음수 ==> [2, 9, 10, 13]
        //     return a-b
        // });  //[2, 9, 10, 13]

        // number 혹은 object 타입 해결방안 1
        // const arrNum2 = [13, 9, 10, 2];
        // arrNum2.sort( function (a, b) {
        //     if(a < b ){
        //         return -1
        //     }else if(b < a){
        //         return 1
        //     } else {
        //         return 0
        //     }
        // });

        // number 혹은 object 타입 해결방안 2
        // const stationeryList = [
        //     {id: 1, product: '연필', stock: 10},
        //     {id: 1, product: '노트', stock: 100},
        //     {id: 1, product: '지우개', stock: 5},
        //     {id: 1, product: '볼펜', stock: 30},
        // ];

        // stationeryList.sort( function (a, b){
        //     return a.stock - b.stock
        // });


        // 3-25. 1개 이상의 요소가 조건에 맞는지 찾을 때에는 some()
        // const cafe = [{
        //     'item' : 'coffee',
        //     'amount' : 5
        // },{
        //     'item' : 'cake',
        //     'amount' : 4
        // },{
        //     'item' : 'tea',
        //     'amount' : 7
        // },{
        //     'item' : 'cookie',
        //     'amount' : 3
        // }];

        // const order = cafe.some ( i => {
        //     return i.amount >= 5
        // });

        // order
        // //expected output: true

        // 3-26. 모든 요소가 조건에 맞는지 찾을 때에는 every()
        // const cafe = ['coffee', 'cake', 'tea', 'cookie']

        // const cafe = [{
        //     'item' : 'coffee',
        //     'amount' : 5
        // },{
        //     'item' : 'cake',
        //     'amount' : 4
        // },{
        //     'item' : 'tea',
        //     'amount' : 7
        // },{
        //     'item' : 'cookie',
        //     'amount' : 3
        // }];

        // const order = cafe.every( i => i.amount >= 3)

        // order
        // //expected output: true

        // map / filter / reduce

        // 배열 메서드 목적
        // - map은 요소의 '맵핑' (map은 새로운 배열을 생성)
        // - filter는 요소의 '여과' (테스트를 통과하는 모든 요소를 모아 새로운 배열로 반환)
        // - reduce는 '누적'할 때 많이 사용합니다.
        
        // map과 filter의 차이를 더 자세히 알고 싶다면?
        // https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-map-%EA%B3%BC-filter-%EC%B0%A8%EC%9D%B4
    </script>
</body>
</html>